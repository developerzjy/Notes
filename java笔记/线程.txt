线程生命周期

==========================
创建状态

可运行状态
运行状态
阻塞状态

消亡状态  最好的方式是线程自然消亡，也就是执行完run方法正常退出，使用stop或destory方法的话使用不当可能会死锁
==========================

线程优先级和调度
可通过setPriority()方法设置优先级，优先级1-10，一般默认是5
新创建的线程从创建它的线程继承优先级
java抢占式调度：优先级高的先运行，如果高优先级的线程从阻塞状态到可运行状态，则这个线程立即被调度运行，成为抢占其他线程

时间片：
相同优先级的线程如果在支持时间片的平台运行，则每个线程最多只能占用时间片的限定时间
不支持时间片的话相同优先级一直占用处理器直到这个线程运行完成或者阻塞
线程可以通过两种方式放弃CPU的使用实现调度：sleep和yield
sleep和yield区别是sleep无条件放弃CPU，yield只将CPU放弃给相同优先级的线程，没有相同优先级的线程时yield被忽略

技巧：对线程的优先级不是很确定的时候通常在原有优先级上加上或者减少一个小的量要比直接设置最大或最小优先级要好的多

==============================
synchronized 锁（对象的锁）
一个对象的所有synchronized方法共享一把锁
1.synchronized 方法：
public synchronized void test(){}
2.synchronized 语句
synchronized(要锁的对象){
    语句块
}

===============================
wait()
notify()
notifyAll()
synchronized
配合实现生产者消费者






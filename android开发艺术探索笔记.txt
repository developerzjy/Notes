activity生命周期
从一个activity跳转到另一个activity
111onPause...
222onCreate...
222onStart...
222onResume...
111onStop...
所以为了让activity2尽快显示出来，在activity1中的一些回收操作放在onStop()里面比较好
另外onPause和onStop尽量不要做比较耗时的操作



（API 13以上）旋转屏幕如果要让activity不重新创建，需要设置activity的configChanges属性值：orientation和screenSize两个属性

Activity的启动模式
如果使用Application Context启动standard模式的activity会报错，因为新启动的standard模式的activity会默认进入启动它的activity栈中，
Application Context可以指定FLAG_ACTIVITY_NEW_TASK标记位，相当于以singleTask模式启动


隐式启动
action必须有，可以有多个（是否有一个匹配就可以？？还是必须所有都必须匹配？？待验证，书中的意思好像是前者）
category可以有可以没有（系统会默认设置一个DEFAULT，所以匹配规则里必须加DEFAULT），必须所有都能匹配
data类似action
（BroadcastReceiver的Intent-filter与上面同理）





IPC 进程间通信
通过指定组建属性 android:process 开启新进程 （应用开启新进程的唯一方法，JNI方式除外）
例如：android:process=":newprocess"  冒号开头，进程名是 包名:newprocess ， 应用私有进程，其他应用无法共享数据 
      android:process="newnew" 没有冒号，进程名是字符串内容，其他应用shareUID和签名相同的话可以共享数据
多进程的问题：静态变量和单例对象失效，线程同步失效，sharedpreference不可靠等

序列化：将对象转换为可存储或者可传输的格式，之后可以通过反序列化得到该对象
Serializable和Parcelable两种方式，前者是Java提供的，后者是android自带的。前者需要大量的I/O操作，开销比较大，后者使用比较麻烦，但是效率很高
Serializable 的serialVersionUID属性的有无影响反序列化（将对象序列化之后存储到文件或者通过网络传输建议使用这个）


Binder












































































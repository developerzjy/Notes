

## 一、基本概念和用法

>在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。例如在哈希表的存取中，JDK1.5之前使用HashMap的get()方法，返回值就是一个Object对象，由于Java语言里面所有的类型都继承于java.lang.Object，那Object转型为任何对象成都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会被转嫁到程序运行期之中。

泛型是JDK1.5的一项新特性，它的本质是将类型参数化，简单的说就是将所操作的数据类型指定为一个参数，在用到的时候通过传参来指定具体的类型。在Java中，这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。一个泛型类的例子如下：

```
//将要操作的数据类型指定为参数T
public class Box<T> {
    private T t;
	
	public void add(T t) {
	    this.t = t;
	}
	
	public T get() {
	    return this.t;
	}
}
```
```
//使用的时候指定具体的类型为Integer
//那么Box类里面的所有T都相当于Integer了
Box<Integer> integerBox = new Box<Integer>();
```

泛型接口和泛型方法的定义和使用示例如下：
```
//泛型接口
interface Show<T,U> {
    void show(T t,U u);
}

class ShowTest implements Show<String,Date> {
    @Override  
    public void show(String str,Date date) {
        System.out.println(str);
        System.out.println(date);
    }
}

public static void main(String[] args) {  
    ShowTest showTest = new ShowTest();
    showTest.show("Hello",new Date());
}
```
```
//泛型方法
public <T, U> T get(T t, U u) {
    if (u != null)
        return t;
    else
        return null;
}

String str = get("Hello", "World");
```

从上面的例子可以看出，用尖括号<>来声明泛型变量，可以有多个类型变量，例如Show<T, U>，但是类型变量名不能重复，例如Show<T, T>是错误的。另外，类型变量名一般使用大写形式，且比较短（不强制，只是一种命名规约），下面是一些常用的类型变量：
- E：元素（Element），多用于java集合框架  
- K：关键字（Key）  
- N：数字（Number）  
- T：类型（Type）  
- V：值（Value）  
- S：第二类型  
- U：第三类型



## 二、泛型变量的类型限定

类型限定就是使用extends关键字对类型变量加以约束，看下面的例子：
```
//定义一个水果类
//里面有一个示例方法getWeight()可以获取水果重量
public class Fruit {
    public int getWeight() {
        return 10; //这里假设所有水果重量都是10
    }
}
public class Apple extends Fruit {}


//定义泛型类Box，并限定类型参数
public class Box<T extends Fruit> {}


//由于Box限定了类型参数，实际类型参数只能是Fruit或者Fruit的子类
Box<Fruit> integerBox = new Box<Fruit>();//编译通过
Box<Apple> integerBox = new Box<Apple>();//编译通过
Box<Integer> integerBox = new Box<Integer>();//编译器报错
```

通过限定，箱子Box就只能装水果了。限定类型参数的好处，举个例子，比如Box里面有一个getBigFruit()方法可以比较两个水果大小，然后返回大的水果，代码如下：
```
public class Box<T extends Fruit>{

    public T getBigFruit(T t1, T t2) {
	
	    // if (!(t1 instanceof Fruit) || !(t2 instanceof Fruit)) {
        //    throw new RuntimeException("T不是水果");
        // }
		
        if (t1.getWeight() > t2.getWeight()) {
            return t1;
        }
        return t2;
    }
}
```
代码中需要注意两个地方：一个是注释的三行，参数限定之后，没必要判断t1和t2的类型了，如果类型不对，在Box实例化的时候就报错了；另一个是t1.getWeight()，在Box类里面，t1是T类型，T类型限定为Fruit，所以这里可以直接调用Fruit里面的方法getWeight()_（确切的说是可以调用Fruit里面可以被子类继承的方法，因为限定之后，实参也可以是Fruit的子类）_，如果不加限定，那么T就默认是Object类型，t1.getWeight()就会报错因为Object里面没有这个方法（调用Object里面的方法是可以的）。这就是是类型限定的两个好处。

类型也可以使用接口限定，比如<T extends MyInterface>，这样的话，只有实现了MyInterface接口的类才能作为实际类型参数。下面是类型限定的几个注意点：
1. 不管限定是类还是接口，统一都使用extends关键字
2. 可以使用&符号给出多个限定，例如：<U extends Number & MyInterface1 & MyInterface1>
3. 多个限制只能有一个类名，其他都是接口名，且类名在最前面。



## 三、通配符

先看三行代码
```
Fruit f = new Apple();
Fruit[] farray = new Apple[10];
ArrayList<Fruit> flist = new ArrayList<Apple>();
```
第一行的写法是很常见的，父类引用指向子类对象，这是java多态的表现。类似的，第二行父类数组的引用指向子类数组对象在java中也是可以的，这称为**数组的协变**。Java把数组设计为协变的，对此是有争议的，有人认为这是一种缺陷。

>虽然Apple[]可以“向上转型”为Fruit[]，但数组元素的实际类型还是Apple，所以只能向数组中放入Apple或者Apple的子类。在上面的代码中，向数组中放入了Fruit对象和Orange对象。对于编译器来说，这是可以通过编译的，但是在运行时期，JVM能够知道数组的实际类型是Apple[]，所以当其它对象加入数组的时候在运行期会抛出异常。

协变的缺陷在于可能的异常发生在运行期，而编译期间无法检查，泛型设计的目的之一就是避免这种问题，**所以泛型是不支持协变的，也就是说，上面的第三行代码是编译不通过的。**但是，有时候是需要建立这种“向上转型”的关系的，比如定义一个方法，打印出任意类型的List中的所有数据，示例如下：

```
public void printCollection(List<Object> collection) {
    for (Object obj : collection) {
        System.out.println(obj);
    }
}
```

这个方法其实是没有什么实用意义的，因为泛型不支持协变，所以下面代码是无法通过编译的：
```
List<Integer> listInteger =new ArrayList<Integer>();
List<String> listString =new ArrayList<String>();

printCollection(listInteger); //编译错误
printCollection(listString); //编译错误
```

上面这个问题，就可以使用通配符来解决了，printCollection()方法改成下面这样即可：
```
public void printCollection(List<?> collection) {
    for (Object obj : collection) {
        System.out.println(obj);
    }
}
```

通配符"?"表示某种特定的类型，但是不知道这个类型到底是什么。因为不知道类型到底是什么，所以`List<?> collection`中的collection不能调用带泛型参数的方法，但是可以调用与泛型参数类型无关的方法，如下：
```
collection.add("a"); //错误，因为add方法参数是泛型E
collection.size(); //正确，因为无参即与泛型参数类型E无关
collection.contains("a"); //正确，因为contains参数是Object类型，与泛型参数类型E无关
```

注：collection.add(null);是可以的，其他任何类型都不可以。


####通配符的边界
通配符可以使用extends和super关键字来限制：
- List<? extends Number> 表示不确定参数类型，但必须是Number类型或者Number子类类型
- List<? super Number> 表示不确定参数类型，但必须是Number类型或者Number的父类类型
- List<?> 表示未受限的通配符，相当于 List<? extends Object>


>注意区分 **泛型变量的类型限定** 和 **通配符的边界限定**：
>1. 泛型变量的类型限定，是在定义泛型类的时候对声明的泛型参数进行限定
>public class Box<T extends Fruit>{}
>2. 通配符的边界限定，是在定义化泛型类的引用的时候对实际泛型参数进行限定
>List<? extends Number> listInteger =new ArrayList<Integer>();
>
>泛型变量的类型限定只能使用extends关键字，通配符的边界限定可以使用extends或super来限定上边界或下边界。







## 四、Java泛型的原理-类型擦除













































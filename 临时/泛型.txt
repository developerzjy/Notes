

## 一、基本概念和用法

>在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。例如在哈希表的存取中，JDK1.5之前使用HashMap的get()方法，返回值就是一个Object对象，由于Java语言里面所有的类型都继承于java.lang.Object，那Object转型为任何对象成都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会被转嫁到程序运行期之中。

泛型是JDK1.5的一项新特性，它的本质是将类型参数化，简单的说就是将所操作的数据类型指定为一个参数，在用到的时候通过传参来指定具体的类型。在Java中，这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。一个泛型类的例子如下：

```
//将要操作的数据类型指定为参数T
public class Box<T> {
    private T t;
	
	public void add(T t) {
	    this.t = t;
	}
	
	public T get() {
	    return this.t;
	}
}
```
```
//使用的时候指定具体的类型为Integer
//那么Box类里面的所有T都相当于Integer了
Box<Integer> integerBox = new Box<Integer>();
```

泛型接口和泛型方法的定义和使用示例如下：
```
//泛型接口
interface Show<T,U> {
    void show(T t,U u);
}

class ShowTest implements Show<String,Date> {
    @Override  
    public void show(String str,Date date) {
        System.out.println(str);
        System.out.println(date);
    }
}

public static void main(String[] args) {  
    ShowTest showTest = new ShowTest();
    showTest.show("Hello",new Date());
}
```
```
//泛型方法
public <T, U> T get(T t, U u) {
    if (u != null)
        return t;
    else
        return null;
}

String str = get("Hello", "World");
```

从上面的例子可以看出，用尖括号<>来声明泛型变量，可以有多个类型变量，例如Show<T, U>，但是类型变量名不能重复，例如Show<T, T>是错误的。另外，类型变量名一般使用大写形式，且比较短（不强制，只是一种命名规约），下面是一些常用的类型变量：
- E：元素（Element），多用于java集合框架  
- K：关键字（Key）  
- N：数字（Number）  
- T：类型（Type）  
- V：值（Value）  
- S：第二类型  
- U：第三类型



## 二、泛型变量的类型限定

类型限定就是使用extends关键字对类型变量加以约束，看下面的例子：
```
//定义一个水果类
//里面有一个示例方法getWeight()可以获取水果重量
public class Fruit {
    public int getWeight() {
        return 10; //这里假设所有水果重量都是10
    }
}
public class Apple extends Fruit {}

--------------------------------------------------------------------------------------------

//定义泛型类Box，并限定类型参数为Fruit
public class Box<T extends Fruit> {}

--------------------------------------------------------------------------------------------

//由于Box限定了类型参数，实际类型参数只能是Fruit或者Fruit的子类
Box<Fruit> integerBox = new Box<Fruit>();//编译通过
Box<Apple> integerBox = new Box<Apple>();//编译通过
Box<Integer> integerBox = new Box<Integer>();//编译器报错
```
上面代码用虚线分为三个部分，第一个部分是准备工作，定义一个水果类Fruit和它的子类Apple；第二部分定义一个泛型类Box，并且限定了泛型参数为Fruit，限定之后，实际类型只能是Fruit或者Fruit的子类，所以第三部分，实际泛型参数是Integer就会报错。
通过限定，箱子Box就只能装水果了，这是有好处的，举个例子，比如Box里面有一个getBigFruit()方法可以比较两个水果大小，然后返回大的水果，代码如下：
```
public class Box<T extends Fruit>{

    public T getBigFruit(T t1, T t2) {
	
	    // if (!(t1 instanceof Fruit) || !(t2 instanceof Fruit)) {
        //    throw new RuntimeException("T不是水果");
        // }
		
        if (t1.getWeight() > t2.getWeight()) {
            return t1;
        }
        return t2;
    }
}
```
代码中需要注意两个地方：一个是注释的三行，参数限定之后，没必要判断t1和t2的类型了，如果类型不对，在Box实例化的时候就报错了；另一个是t1.getWeight()，在Box类里面，t1是T类型，T类型限定为Fruit，所以这里可以直接调用Fruit里面的方法getWeight()_（确切的说是可以调用Fruit里面可以被子类继承的方法，因为限定之后，实参也可以是Fruit的子类）_，如果不加限定，那么T就默认是Object类型，t1.getWeight()就会报错因为Object里面没有这个方法（调用Object里面的方法是可以的）。这就是是类型限定的两个好处。

类型也可以使用接口限定，比如<T extends MyInterface>，这样的话，只有实现了MyInterface接口的类才能作为实际类型参数。下面是类型限定的几个注意点：
1. 不管限定是类还是接口，统一都使用extends关键字
2. 可以使用&符号给出多个限定，例如：<U extends Number & MyInterface1 & MyInterface1>
3. 多个限制只能有一个类名，其他都是接口名，且类名在最前面。



## 三、通配符

先看三行代码
```
Fruit f = new Apple();
Fruit[] farray = new Apple[10];
ArrayList<Fruit> flist = new ArrayList<Apple>();
```
第一行的写法是很常见的，父类引用指向子类对象，这是java多态的表现。类似的，第二行父类数组的引用指向子类数组对象在java中也是可以的，这称为**数组的协变**。Java把数组设计为协变的，对此是有争议的，有人认为这是一种缺陷。

>虽然Apple[]可以“向上转型”为Fruit[]，但数组元素的实际类型还是Apple，所以只能向数组中放入Apple或者Apple的子类。在上面的代码中，向数组中放入了Fruit对象和Orange对象，对于编译器来说，这是可以通过编译的，但是在运行时期，JVM能够知道数组的实际类型是Apple[]，所以当其它对象加入数组的时候在运行期会抛出异常。

协变的缺陷在于可能的异常发生在运行期，而编译期间无法检查，泛型设计的目的之一就是避免这种问题，**所以泛型是不支持协变的，也就是说，上面的第三行代码是编译不通过的。**但是，有时候是需要建立这种“向上转型”的关系的，比如定义一个方法，打印出任意类型的List中的所有数据，示例如下：

```
public void printCollection(List<Object> collection) {
    for (Object obj : collection) {
        System.out.println(obj);
    }
}

------------------------------------
List<Integer> listInteger =new ArrayList<Integer>();
List<String> listString =new ArrayList<String>();

printCollection(listInteger); //编译错误
printCollection(listString); //编译错误
```
因为泛型不支持协变，即`List<Object> collection = new ArrayList<Integer>();`无法通过编译，所以`printCollection(listInteger)`就会报错。
这时就需要使用**通配符**来解决，通配符<?>，用来表示某种特定的类型，但是不知道这个类型到底是什么。例如下面的例子都是合法的：
```
List<?> collection1 = new ArrayList<Fruit>();
List<?> collection2 = new ArrayList<Number>();
List<?> collection3 = new ArrayList<String>();
List<?> collection4 = new ArrayList<任意类型>();
// 对比不合法的 List<Fruit> flist = new ArrayList<Apple>();
```
所以printCollection()方法改成下面这样即可：
```
public void printCollection(List<?> collection) {
    for (Object obj : collection) {
        System.out.println(obj);
    }
}
```
这就是通配符的简单用法。需要注意的是，因为不知道 "?" 类型到底是什么，所以`List<?> collection`中的collection不能调用带泛型参数的方法，但是可以调用与泛型参数类型无关的方法，如下：
```
collection.add("a"); //错误，因为add方法参数是泛型E
collection.size(); //正确，因为无参即与泛型参数类型E无关
collection.contains("a"); //正确，因为contains参数是Object类型，与泛型参数类型E无关
```

注：collection.add(null);是可以的，除了null其他任何类型都不可以。


####通配符的边界
通配符可以使用extends和super关键字来限制：
- List<? extends Number> 表示不确定参数类型，但必须是Number类型或者Number子类类型，这是上边界限定
- List<? super Number> 表示不确定参数类型，但必须是Number类型或者Number的父类类型，这是下边界限定
- List<?> 表示未受限的通配符，相当于 List<? extends Object>


>注意区分 **泛型变量的类型限定** 和 **通配符的边界限定**：
>1. 泛型变量的类型限定，是在定义泛型类的时候对声明的泛型参数进行限定
>public class Box<T extends Fruit>{}
>2. 通配符的边界限定，是在定义化泛型类的引用的时候对实际泛型参数进行限定
>List<? extends Number> listInteger =new ArrayList<Integer>();
>
>泛型变量的类型限定只能使用extends关键字，通配符的边界限定可以使用extends或super来限定上边界或下边界。





## 四、Java泛型的原理-类型擦除
Java中的泛型是通过类型擦除来实现的伪泛型。类型擦除指的是从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码，看下面的例子：

泛型的Java代码如下：
```
class Pair<T> {
    private T value;
    public T getValue() {
        return value;
    }
    public void setValue(T  value) {
        this.value = value;
    }
}
```
泛型Java代码，经过编译器编译后，会擦除泛型信息，将泛型代码转换为如下的普通Java代码：
```
class Pair {
    private Object value;
    public Object getValue() {
        return value;
    }
    public void setValue(Object  value) {
        this.value = value;
    }
}
```
由上面的例子可知，泛型擦除的结果就是用Object替换T（在这里替换T的Object称为原始类型），最终生成一个普通的类。上面的例子的原始类型Obejct是因为在Pair<T>中，T是一个无限定的类型变量，所以用Object替换。如果T被限定了，比如<T extends Number>，那么原始类型就是Number，擦除后用Number替换泛型类里面的T。多个限定的话，那么使用第一个边界的类型变量来作为原始类型。
至此可以知道，类型擦除的过程：
1. 移除所有的类型参数。
2. 将所有移除的泛型参数用其最左边界（最顶级的父类型）类型替换。

**泛型只存在于代码中，泛型类的类型参数在编译时都会被擦除，虚拟机中没有泛型，只有普通类和普通方法。**

-------------------------------------

####泛型擦除（伪泛型）带来的一些问题

首先是方法签名的问题：
```
public void test(List<String> ls){
    System.out.println("Sting");
}
public void test(List<Integer> li){
    System.out.println("Integer");
}
```
上面的两个方法，编译后泛型被擦除，参数类型都是List，所以它们不是重载而是同一个方法，如果同时存在于一个类中是无法通过编译的。







































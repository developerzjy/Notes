

## 一、基本概念和用法

>在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。例如在哈希表的存取中，JDK1.5之前使用HashMap的get()方法，返回值就是一个Object对象，由于Java语言里面所有的类型都继承于java.lang.Object，那Object转型为任何对象成都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会被转嫁到程序运行期之中。

泛型是JDK1.5的一项新特性，它的本质是将类型参数化，简单的说就是将所操作的数据类型指定为一个参数，在用到的时候通过传参来指定具体的类型。在Java中，这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。一个泛型类的例子如下：

```
//将要操作的数据类型指定为参数T
public class Box<T> {
    private T t;
	
	public void add(T t) {
	    this.t = t;
	}
	
	public T get() {
	    return this.t;
	}
}
```
```
//使用的时候指定具体的类型为Integer
//那么Box类里面的所有T都相当于Integer了
Box<Integer> integerBox = new Box<Integer>();
```

泛型接口和泛型方法的定义和使用示例如下：
```
//泛型接口
interface Show<T,U> {
    void show(T t,U u);
}

class ShowTest implements Show<String,Date> {
    @Override  
    public void show(String str,Date date) {
        System.out.println(str);
        System.out.println(date);
    }
}

public static void main(String[] args) {  
    ShowTest showTest = new ShowTest();
    showTest.show("Hello",new Date());
}
```
```
//泛型方法
public <T, U> T get(T t, U u) {
    if (u != null)
        return t;
    else
        return null;
}

String str = get("Hello", "World");
```

从上面的例子可以看出，用尖括号<>来声明泛型变量，可以有多个类型变量，例如Show<T, U>，但是类型变量名不能重复，例如Show<T, T>是错误的。另外，类型变量名一般使用大写形式，且比较短（不强制，只是一种命名规约），下面是一些常用的类型变量：
- E：元素（Element），多用于java集合框架  
- K：关键字（Key）  
- N：数字（Number）  
- T：类型（Type）  
- V：值（Value）  
- S：第二类型  
- U：第三类型



## 二、泛型变量的类型限定

类型限定就是使用extends关键字对类型变量加以约束，看下面的例子：
```
//定义一个水果类
//里面有一个示例方法getWeight()可以获取水果重量
public class Fruit {
    public int getWeight() {
        return 10; //这里假设所有水果重量都是10
    }
}
public class Apple extends Fruit {}


//定义泛型类Box，并限定类型参数
public class Box<T extends Fruit> {}


//由于Box限定了类型参数，实际类型参数只能是Fruit或者Fruit的子类
Box<Fruit> integerBox = new Box<Fruit>();//编译通过
Box<Apple> integerBox = new Box<Apple>();//编译通过
Box<Integer> integerBox = new Box<Integer>();//编译器报错
```

通过限定，箱子Box就只能装水果了。限定类型参数的好处，举个例子，比如Box里面有一个getBigFruit()方法可以比较两个水果大小，然后返回大的水果，代码如下：
```
public class Box<T extends Fruit>{

    public T getBigFruit(T t1, T t2) {
	
	    // if (!(t1 instanceof Fruit) || !(t2 instanceof Fruit)) {
        //    throw new RuntimeException("T不是水果");
        // }
		
        if (t1.getWeight() > t2.getWeight()) {
            return t1;
        }
        return t2;
    }
}
```
代码中需要注意两个地方：一个是注释的三行，参数限定之后，没必要判断t1和t2的类型了，如果类型不对，在Box实例化的时候就报错了；另一个是t1.getWeight()，在Box类里面，t1是T类型，T类型限定为Fruit，所以这里可以直接调用Fruit里面的方法getWeight()_（确切的说是可以调用Fruit里面可以被子类继承的方法，因为限定之后，实参也可以是Fruit的子类）_，如果不加限定，那么T就默认是Object类型，t1.getWeight()就会报错因为Object里面没有这个方法（调用Object里面的方法是可以的）。这就是是类型限定的两个好处。

类型也可以使用接口限定，比如<T extends MyInterface>，这样的话，只有实现了MyInterface接口的类才能作为实际类型参数。下面是类型限定的几个注意点：
1. 不管限定是类还是接口，统一都使用extends关键字
2. 可以使用&符号给出多个限定，例如：<U extends Number & MyInterface1 & MyInterface1>
3. 多个限制只能有一个类名，其他都是接口名，且类名在最前面。



## 三、通配符

先看两行代码
```
Fruit[] farray = new Apple[10];
ArrayList<Fruit> flist = new ArrayList<Apple>();
```





















## 四、Java泛型的原理-类型擦除
















































本文分析HashMap的实现原理。


#####数据结构（散列表）
HashMap是一个散列表（也叫哈希表），用来存储键值对(key-value)映射。散列表是一种数组和链表的结合体，结构图如下：

==========>图

简单来说散列表就是一个数组（上图纵向），数组的每个元素是一个链表（上图横向），类似二维数组。链表的每个节点就是我们存储的key-value数据（代码中将key和value封装成Entry对象作为链表的节点）。



#####哈希算法
对于散列表，不管是存值还是取值，都需要通过Key来定位散列表中的一个具体的位置（即某个链表的某个节点），计算这个位置的方法就是哈希算法。**大概过程是这样的：用Key的hash值对数组长度做取余操作得到一个整数，这个整数作为数组中的索引得到这个索引位置的链表。得到链表之后，就可以存值和取值了。存值简单，直接把数据插入到链表的头部或者尾部即可（或者已存在就替换）；如果是取值，就遍历链表，通过key的equals方法找到具体的节点。**


如果理解了上面描述的哈希算法，那么同时会明白了一些知识点的原理：
- 不同的key具体相同的哈希值叫做哈希冲突，**HashMap解决哈希冲突的方法是链表法**，将具有相同哈希值的key放在同一个链表中，然后利用key类的equals方法来确定具体是哪个key。
- Key的唯一性是通过哈希值和equals方法共同决定的。HashSet是基于HashMap实现的，它没有重复元素的特点是利用HashMap没有重复键实现的。所以，HashMap的键类或者Set集合里面的元素类，必须同时实现了hashCode方法和equals方法。


#####为什么HashMap大小是2的整数次幂的时候效率最高
通过散列表的结构特点可以知道，如果数组中每个链表只有一个元素，那么get元素的时候效率是最高的，也就是说我们应该尽量保证hashmap里面的元素均匀分布，降低遍历链表的代价。如何保证均匀分布？前面的哈希算法说到，通过取余将Key转换成数组下标，这样可以认为是均匀的。但是，源码中并没有直接用%操作符取余，而是使用了更高效的与运算：
```
/**
 * Returns index for hash code h.
 */
static int indexFor(int h, int length) {
    // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
    return h & (length-1);
}
```
这样就多了一些限制，因为只有当length是2的整数次幂的时候，h & (length-1) = h % length才成立。当然，如果length不是2的整数次幂，h & (length-1)的结果也一定比length小，将Key转换成数组下标也没什么问题，但是，这样会导致元素分布不均匀严重影响散列表的访问效率。
































